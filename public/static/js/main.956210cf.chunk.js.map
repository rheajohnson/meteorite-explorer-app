{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["Header","Footer","Content","Title","Search","input","App","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","columns","title","dataIndex","key","render","text","react_default","a","createElement","main_default","highlightStyle","backgroundColor","padding","searchWords","state","searchInput","textToHighlight","toString","onSearch","length","filteredInput","data","filter","value","name","toLowerCase","includes","charAt","setState","loading","filteredDb","message","error","setInputValue","e","target","sortedInfo","getLandings","_this2","fetch","method","body","JSON","stringify","query","headers","Content-Type","then","res","json","response","success","landings","map","dateToFormat","year","formattedDate","dist_default","format","objectSpread","id","catch","_this3","layout","className","level","style","color","placeholder","enterButton","size","onChange","table","dataSource","es_button","type","React","Component","Boolean","window","location","hostname","match","ReactDOM","App_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.956210cf.chunk.js","sourcesContent":["import React from \"react\";\nimport { Layout } from \"antd\";\nimport { Table, Typography, Input, message, Button } from \"antd\";\nimport Highlighter from \"react-highlight-words\";\nimport Moment from \"react-moment\";\nimport \"./App.css\";\n\nconst { Header, Footer, Content } = Layout;\nconst { Title } = Typography;\nconst Search = Input.Search;\n\nexport default class App extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      data: [],\n      filteredDb: [],\n      loading: false,\n      searchInput: \"\",\n      sortedInfo: null\n    };\n  }\n\n  columns = [\n    {\n      title: \"Name\",\n      dataIndex: \"name\",\n      key: \"name\",\n      render: text => (\n        <Highlighter\n          highlightStyle={{ backgroundColor: \"#ffc069\", padding: 0 }}\n          searchWords={[this.state.searchInput]}\n          textToHighlight={text ? text.toString() : null}\n        />\n      )\n    },\n    {\n      title: \"ID\",\n      dataIndex: \"id\",\n      key: \"id\"\n    },\n\n    {\n      title: \"Recclass\",\n      dataIndex: \"recclass\",\n      key: \"recclass\"\n    },\n    {\n      title: \"Mass (g)\",\n      dataIndex: \"mass\",\n      key: \"mass\"\n    },\n\n    {\n      title: \"Year\",\n      dataIndex: \"formattedDate\",\n      key: \"formattedDate\"\n    }\n  ];\n\n  componentDidMount() {\n    this.getLandings();\n  }\n\n  getLandings() {\n    this.setState({ loading: true });\n    const reqBody = {\n      query: `\n        query {\n          landings {\n            name\n            id\n            recclass\n            mass\n            year\n          }\n        }\n      `\n    };\n\n    fetch(\"/graphql\", {\n      method: \"POST\",\n      body: JSON.stringify(reqBody),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    })\n      .then(res => res.json())\n      .then(response => {\n        if (!response.data) {\n          message.error(\"Failed to fetch data ðŸ˜­\");\n          this.setState({ loading: false });\n          return;\n        }\n        message.success(\"Successfully grabbed data ðŸ˜„\");\n        const data = response.data.landings.map(value => {\n          const dateToFormat = value.year;\n          const formattedDate = <Moment format=\"YYYY\">{dateToFormat}</Moment>;\n          return { ...value, key: value.id, formattedDate };\n        });\n        this.setState({ data, filteredDb: data }, () => {\n          this.setState({ loading: false });\n        });\n      })\n      .catch(() => {\n        message.error(\"Failed to fetch data ðŸ˜­\");\n        this.setState({ loading: false });\n        return;\n      });\n  }\n\n  onSearch = text => {\n    if (text.length === 0) {\n      this.setState({ loading: true, filteredDb: this.state.data }, () => {\n        this.setState({ loading: false });\n      });\n      return;\n    }\n    let filteredInput = this.state.data.filter(value => {\n      return (\n        value.name.toLowerCase().includes(text.toLowerCase()) &&\n        value.name.toLowerCase().charAt(0) === text.toLowerCase().charAt(0)\n      );\n    });\n    this.setState({ loading: true, filteredDb: filteredInput }, () => {\n      this.setState({ loading: false });\n    });\n    if (filteredInput.length === 0) {\n      message.error(\"No search results found ðŸ˜®\");\n    }\n  };\n\n  setInputValue = e => {\n    if (e.target.value.length < 2) return;\n    const value = e.target.value;\n    this.setState({ searchInput: value });\n  };\n\n  render() {\n    return (\n      <Layout className=\"app-container\">\n        <Header className=\"header-container\">\n          <Title level={3} style={{ color: \"white\" }}>\n            Meteorite Explorer\n          </Title>\n        </Header>\n        <Content className=\"content-container\">\n          <Search\n            placeholder=\"Search meteor name\"\n            className=\"search-container\"\n            enterButton=\"Search\"\n            size=\"large\"\n            onSearch={value => this.onSearch(value)}\n            onChange={this.setInputValue}\n          />\n          <Table\n            className=\"table-container\"\n            columns={this.columns}\n            dataSource={this.state.filteredDb}\n            size=\"small\"\n            loading={this.state.loading}\n          />\n        </Content>\n        <Footer className=\"footer-container\">\n          <Button size=\"small\" type=\"primary\">\n            View GitHub\n          </Button>\n        </Footer>\n      </Layout>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"./index.css\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\nserviceWorker.unregister();\n"],"sourceRoot":""}